(* Automatically generated by checker_builder. DO NOT EDIT DIRECTLY! *)

open Common
open Error
open FixedPoint
open TokenMetadata

type {{ module_name }} = Ligo.nat

let[@inline] {{ module_name }}_scaling_factor_int = Ligo.int_from_literal "{{ token_config.scaling_factor }}"
let[@inline] {{ module_name }}_scaling_factor_nat = Ligo.nat_from_literal "{{ token_config.scaling_factor }}n"

(* Basic arithmetic operations. *)
let[@inline] {{ module_name }}_add (x: {{ module_name }}) (y: {{ module_name }}) = Ligo.add_nat_nat x y
let {{ module_name }}_sub (x: {{ module_name }}) (y: {{ module_name }}) =
  match Ligo.is_nat (Ligo.sub_nat_nat x y) with
  | Some n -> n
  | None -> (Ligo.failwith internalError_{{ module_name.capitalize() }}SubNegative : {{ module_name }})

let[@inline] {{ module_name }}_min (x: {{ module_name }}) (y: {{ module_name }}) = if Ligo.leq_nat_nat x y then x else y
let[@inline] {{ module_name }}_max (x: {{ module_name }}) (y: {{ module_name }}) = if Ligo.geq_nat_nat x y then x else y

let[@inline] {{ module_name }}_zero = Ligo.nat_from_literal "0n"
let[@inline] {{ module_name }}_one = {{ module_name }}_scaling_factor_nat

(* Conversions to/from other types. *)
let[@inline] {{ module_name }}_of_denomination (amnt: Ligo.nat) : {{ module_name }} = amnt
let[@inline] {{ module_name }}_to_denomination_int (amnt: {{ module_name }}) : Ligo.int = Ligo.int amnt
let[@inline] {{ module_name }}_to_denomination_nat (amnt: {{ module_name }}) : Ligo.nat = amnt

let {{ module_name }}_of_fraction_ceil (x_num: Ligo.int) (x_den: Ligo.int) : {{ module_name }} =
  assert (Ligo.gt_int_int x_den (Ligo.int_from_literal "0"));
  if Ligo.lt_int_int x_num (Ligo.int_from_literal "0")
  then (Ligo.failwith internalError_{{ module_name.capitalize() }}OfFractionCeilNegative : {{ module_name }})
  else Ligo.abs (cdiv_int_int (Ligo.mul_int_int x_num {{ module_name }}_scaling_factor_int) x_den)

let {{ module_name }}_of_fraction_floor (x_num: Ligo.int) (x_den: Ligo.int) : {{ module_name }} =
  assert (Ligo.gt_int_int x_den (Ligo.int_from_literal "0"));
  if Ligo.lt_int_int x_num (Ligo.int_from_literal "0")
  then (Ligo.failwith internalError_{{ module_name.capitalize() }}OfFractionFloorNegative : {{ module_name }})
  else Ligo.abs (fdiv_int_int (Ligo.mul_int_int x_num {{ module_name }}_scaling_factor_int) x_den)

let[@inline] {{ module_name }}_scale (amnt: {{ module_name }}) (fp: fixedpoint) =
  {{ module_name }}_of_fraction_floor
    (Ligo.mul_int_nat (fixedpoint_to_raw fp) amnt)
    (Ligo.mul_int_int fixedpoint_scaling_factor {{ module_name }}_scaling_factor_int)

let[@inline] geq_{{ module_name }}_{{ module_name }} = Ligo.geq_nat_nat
let[@inline] leq_{{ module_name }}_{{ module_name }} = Ligo.leq_nat_nat

let[@inline] lt_{{ module_name }}_{{ module_name }} = Ligo.lt_nat_nat
let[@inline] gt_{{ module_name }}_{{ module_name }} = Ligo.gt_nat_nat

let[@inline] eq_{{ module_name }}_{{ module_name }} = Ligo.eq_nat_nat

(* BEGIN_OCAML *)
[@@@coverage off]
let[@inline] {{ module_name }}_to_ratio (amnt: {{ module_name }}) : ratio = make_ratio (Ligo.int amnt) {{ module_name }}_scaling_factor_int

let {{ module_name }}_compare x y = compare_nat x y

let show_{{ module_name }} amnt =
  let zfill s width = match Stdlib.(width - (String.length s)) with
    | to_fill when to_fill <= 0 -> s
    | to_fill -> (String.make to_fill '0') ^ s
  in
  let as_string =
    if {{ module_name }}_decimal_digits = Ligo.nat_from_literal "0n" then
      Ligo.string_of_nat amnt
    else
      let d, r = Option.get (Ligo.ediv_nat_nat amnt {{ module_name }}_scaling_factor_nat) in
      let {{ module_name }}_decimal_digits = Stdlib.int_of_string (Ligo.string_of_nat {{ module_name }}_decimal_digits) in (* little hacky *)
      (Ligo.string_of_nat d) ^ "." ^ zfill (Ligo.string_of_nat r) {{ module_name }}_decimal_digits
  in as_string ^ "{{ module_name }}"

let pp_{{ module_name }} ppf amnt = Format.fprintf ppf "%s" (show_{{ module_name }} amnt)

[@@@coverage on]
(* END_OCAML *)
