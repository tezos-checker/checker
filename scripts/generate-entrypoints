#!/usr/bin/env ruby

EntrypointInfo = Struct.new(:name, :param_sig)
ViewInfo= Struct.new(:name, :param_sig, :return_sig)

views = []
entrypoints = []
ARGF.each_line do |line|
   case line
   when /^val +entrypoint_(\S+).*checker\s+\*\s+(.*?)\s+->/ then entrypoints << EntrypointInfo.new( $1, $2)
   when /^val +entrypoint_/ then raise "#{ARGF.filename}:#{ARGF.lineno}: Unrecognised entrypoint decl #{line}"
   when /^val view_(\S+) *: *\((.*?) *\* *checker\) *-> *(.*)/ then views << ViewInfo.new($1, $2.strip, $3.strip)
   when /^val +view/ then raise "#{ARGF.filename}:#{ARGF.lineno}: Unrecognised view decl #{line}"
   end
end

def to_entrypoint_name(str)
  str.capitalize
end


puts <<EOF
(* GENERATED BY generate-entrypoints SCRIPT, DO NOT EDIT BY HAND *)

open CheckerTypes
open Checker
open Kit
open Lqt
open LiquidationAuctionTypes
open LiquidationAuctionPrimitiveTypes
open Ctez
open Fa2Interface
open Error

EOF


# Generate the lazy_params type

puts "type lazy_params ="
entrypoints.each do |e|
  puts "   | #{to_entrypoint_name e.name} of #{e.param_sig}"
end

puts

# Generate unique identifiers for entrypoint functions
entrypoints.each.with_index do |e, n|
  puts "let[@inline] lazy_id_#{e.name} = Ligo.int_from_literal \"#{n}\""
end
puts

puts "type lazy_function = checker * Ligo.bytes -> LigoOp.operation list * checker"
puts
puts "let lazyParamsToLazyFunctionId (p: lazy_params) : lazy_function_id * Ligo.bytes =
  match p with
"
entrypoints.each do |e|
  puts "   | #{to_entrypoint_name e.name} a -> (lazy_id_#{e.name}, Ligo.Bytes.pack a)"
end

# Generate wrappers for entrypoint functions
entrypoints.each do |entrypoint|
  puts "
(* BEGIN_LIGO
let lazy_fun_#{entrypoint.name} (checker, params: checker * Ligo.bytes): LigoOp.operation list * checker =
  match (Ligo.Bytes.unpack params: #{entrypoint.param_sig} option) with
  | Some p -> entrypoint_#{entrypoint.name} (checker, p)
  | None -> (failwith error_UnexpectedParams : LigoOp.operation list * checker)
END_LIGO *)
"
end
puts

# Generate views for entrypoint functions
views.each do |view|
  puts "
let wrapper_view_#{view.name} (param, wrapper: #{view.param_sig} * wrapper): #{view.return_sig} =
  match wrapper.deployment_state with
  | Sealed checker -> view_#{view.name} (param, checker)
  | Unsealed _ -> (Ligo.failwith error_ContractNotDeployed: #{view.return_sig})
"
end
puts

# Generate an ocaml shim to avoid packing
puts "(* BEGIN_OCAML *)"
puts "let runLazyParams (params: lazy_params) (checker: checker): LigoOp.operation list * checker =
  match params with
"
entrypoints.each do |e|
  puts "   | #{to_entrypoint_name e.name} a -> entrypoint_#{e.name} (checker, a)"
end
puts "(* END_OCAML *)"
